# 2020编译涉及文档

## RiverTxx

## 一、文法

### 1.1 文法

＜加法运算符＞ ::= +｜-     //*测试程序需出现2种符号*

＜乘法运算符＞ ::= \*｜/     //*测试程序需出现2种符号*

＜关系运算符＞ ::= <｜<=｜>｜>=｜!=｜==  //*测试程序需出现6种符号*

＜字母＞  ::= ＿｜a｜．．．｜z｜A｜．．．｜Z  //*测试程序需出现下划线、小写字母、大写字母3种情况*

＜数字＞  ::= ０｜１｜．．．｜９            //*测试程序至少出现1次数字*

＜字符＞  ::= '＜加法运算符＞'｜'＜乘法运算符＞'｜'＜字母＞'｜'＜数字＞'  //*测试程序至少出现4种类型的字符*

＜字符串＞  ::= "｛十进制编码为32,33,35-126的ASCII字符｝" //字符串中要求至少有一个字符  测试程序至少出现1次字符串，不必覆盖所有字符

＜程序＞  ::= ［＜常量说明＞］［＜变量说明＞］{＜有返回值函数定义＞|＜无返回值函数定义＞}＜主函数＞  //*测试程序只需出现有/无常量说明、有/无变量说						明、有/无函数定义的情况，不必考虑其排列组合*

＜常量说明＞ ::= const＜常量定义＞;{ const＜常量定义＞;}  //*测试程序需出现一个const语句、2个或2个以上const语句2种情况*

＜常量定义＞  ::=  int＜标识符＞＝＜整数＞{,＜标识符＞＝＜整数＞} | char＜标识符＞＝＜字符＞{,＜标识符＞＝＜字符＞} 
								 //*测试程序需出现int和char 2种类型的常量，需出现1个常量定义、2个或2个以上常量定义2种情况，不必考虑排列组合*

＜无符号整数＞ ::= ＜数字＞｛＜数字＞｝ //*测试程序需出现1位整数、2位及2位以上整数2种情况*

＜整数＞    ::= ［＋｜－］＜无符号整数＞ //*测试程序需出现不带+/-号的整数、带+和-号的整数*

＜标识符＞   ::=  ＜字母＞｛＜字母＞｜＜数字＞｝ 
							//*标识符和保留字都不区分大小写，比如if和IF均为保留字，不允许出现与保留字相同的标识符*
							//*测试程序需出现只有1个字母的标识符，有后续字母或数字2种情况*

＜声明头部＞  ::=  int＜标识符＞ |char＜标识符＞  //*测试程序需出现int 和 char2种类型的声明头部*

＜常量＞  ::= ＜整数＞|＜字符＞  //*测试程序需出现整数和字符2种情况的常量*

＜变量说明＞ ::= ＜变量定义＞;{＜变量定义＞;}  //*测试程序需出现只有1项变量定义、2项及2项以上变量定义2种情况*

＜变量定义＞ ::= ＜变量定义无初始化＞|＜变量定义及初始化＞ //*测试程序需出现变量定义无初始化和有初始化2种情况*

＜变量定义无初始化＞ ::= ＜类型标识符＞(＜标识符＞|＜标识符＞'['＜无符号整数＞']'|＜标识符＞'['＜无符号整数＞']''['＜无符号整数＞']'){,(＜标识符＞|＜标识											 符＞'['＜无符号整数＞']'|＜标识符＞'['＜无符号整数＞']''['＜无符号整数＞']' )}
											//*变量包括简单变量、一维、二维数组，＜无符号整数＞表示数组各维元素的个数，其值需大于0，数组元素按行优先存储*
											//*变量没有初始化的情况下没有初值*
										   //*测试程序需出现一维数组定义、二维数组定义2种情况；需出现一个类型标识符后有1项、2项及2项以上变量2种情况，不考虑排列组合*

＜变量定义及初始化＞ ::= ＜类型标识符＞＜标识符＞=＜常量＞|＜类型标识符＞＜标识符＞'['＜无符号整数＞']'='{'＜常量＞{,＜常量＞}'}'|＜类型标识符＞＜标识											符＞'['＜无符号整数＞']''['＜无符号整数＞']'='{''{'＜常量＞{,＜常量＞}'}'{, '{'＜常量＞{,＜常量＞}'}'}'}'
											//*简单变量、一维、二维数组均可在声明的时候赋初值，＜无符号整数＞表示数组各维元素的个数，其值需大于0，数组元素按行优先												存储，＜常量＞的类型应与＜类型标识符＞完全一致，否则报错；每维初值的个数与该维元素个数一致，否则报错，无缺省值*

＜类型标识符＞    ::=  int | char //*测试程序需出现int、char 2种类型标识符*

＜有返回值函数定义＞ ::=  ＜声明头部＞'('＜参数表＞')' '{'＜复合语句＞'}'    //*测试程序需出现有返回值的函数定义*

＜无返回值函数定义＞ ::= void＜标识符＞'('＜参数表＞')''{'＜复合语句＞'}'   //*测试程序需出现无返回值的函数定义*

＜复合语句＞  ::=  ［＜常量说明＞］［＜变量说明＞］＜语句列＞        //*测试程序的复合语句需出现有和无常量说明2种情况、有和无变量说明2种情况，不必考								虑其排列组合*

＜参数表＞   ::=  ＜类型标识符＞＜标识符＞{,＜类型标识符＞＜标识符＞}| ＜空＞  //*测试程序需出现无参数、1个参数、2个及2个以上参数3种情况*

＜主函数＞   ::= void main‘(’‘)’ ‘{’＜复合语句＞‘}’                             //*每个测试程序有且仅有1个主函数*

＜表达式＞  ::= ［＋｜－］＜项＞{＜加法运算符＞＜项＞}  //*[+|-]只作用于第一个<项>* 
							//*测试程序的表达式需出现项之前无符号、有+和-号的情况；表达式只有1个项、2个及2个以上项2种情况，不必考虑排列组合*

＜项＞   ::= ＜因子＞{＜乘法运算符＞＜因子＞}   //*测试程序的项需出现只有1个因子、2个及2个以上因子2种情况*

＜因子＞  ::= ＜标识符＞|＜标识符＞'['＜表达式＞']'|＜标识符＞'['＜表达式＞']''['＜表达式＞']'|'('＜表达式＞')'｜＜整数＞|＜字符＞｜＜有返回值函数调用语句						＞
					  // *char 类型的变量或常量，用字符的ASCII 码对应的整数参加运算*
					  //*＜标识符＞'['＜表达式＞']'和＜标识符＞'['＜表达式＞']''['＜表达式＞']'中的＜表达式＞只能是整型，下标从0开始*
					  // *单个＜标识符＞不包括数组名，即数组不能整体参加运算，数组元素可以参加运算*
				     //*测试程序的因子需出现7种情况*

＜语句＞  ::= ＜循环语句＞｜＜条件语句＞| ＜有返回值函数调用语句＞; |＜无返回值函数调用语句＞;｜＜赋值语句＞;｜＜读语句＞;｜＜写语句＞;｜＜情况语句						＞｜＜空＞;|＜返回语句＞; | '{'＜语句列＞'}'     //*测试程序需出现11种语句*

＜赋值语句＞  ::=  ＜标识符＞＝＜表达式＞|＜标识符＞'['＜表达式＞']'=＜表达式＞|＜标识符＞'['＜表达式＞']''['＜表达式＞']' =＜表达式＞
							  //*＜标识符＞＝＜表达式＞中的<标识符>不能为常量名和数组名*
							//*测试程序需出现给简单变量赋值、一维数组元素赋值、二维数组元素赋值3种情况*

＜条件语句＞ ::= if '('＜条件＞')'＜语句＞［else＜语句＞］  //*测试程序需出现有else和无else 2种形式的条件语句*

＜条件＞  ::= ＜表达式＞＜关系运算符＞＜表达式＞      
					 //*表达式需均为整数类型才能进行比较*
					/*测试程序中需出现条件*

＜循环语句＞  ::=  while '('＜条件＞')'＜语句＞| for'('＜标识符＞＝＜表达式＞;＜条件＞;＜标识符＞＝＜标识符＞(+|-)＜步长＞')'＜语句＞   
								//*for语句先进行条件判断，符合条件再进入循环体*
								//*测试程序中需出现while和for 2种循环语句，for语句应出现+步长和-步长2种情况*

＜步长＞::= ＜无符号整数＞ 

＜情况语句＞ ::=  switch ‘(’＜表达式＞‘)’ ‘{’＜情况表＞＜缺省＞‘}’   //*测试程序需出现情况语句*

＜情况表＞  ::=  ＜情况子语句＞{＜情况子语句＞}            //*测试程序需出现只有1个情况子语句、2个及2个以上情况子语句2种情况*

＜情况子语句＞ ::=  case＜常量＞：＜语句＞              //*测试程序中需出现情况子语句*

＜缺省＞  ::=  default :＜语句＞                        //*测试程序中需出现缺省语句*
						//*情况语句中，switch后面的表达式和case后面的常量只允许出现int和char类型；每个情况子语句执行完毕后，不继续执行后面的情况子语句*

＜有返回值函数调用语句＞ ::= ＜标识符＞'('＜值参数表＞')'     //*测试程序需出现有返回值的函数调用语句*

＜无返回值函数调用语句＞ ::= ＜标识符＞'('＜值参数表＞')'     //*测试程序需出现无返回值的函数调用语句*
													//*函数调用时，只能调用在之前已经定义过的函数，对是否有返回值的函数都是如此*

＜值参数表＞  ::= ＜表达式＞{,＜表达式＞}｜＜空＞          
							//*实参的表达式不能是数组名，可以是数组元素*
							//*实参的计算顺序,要求生成的目标码运行结果与Clang8.0.1 编译器运行的结果一致*
							//*测试程序中需出现无实参、1个实参、2个及2个以上实参3种情况*

＜语句列＞  ::= ｛＜语句＞｝/ /*测试程序的语句列需出现无语句、有语句2种情况*

＜读语句＞  ::= scanf '('＜标识符＞')' 
							//*从标准输入获取<标识符>的值，该标识符不能是常量名和数组名*
       					 //*生成的PCODE或MIPS汇编在运行时，对每一个scanf语句，无论标识符的类型是char还是int，末尾需回车；在testin.txt文件中的输入数据也是每								项在一行*
						   //*生成MIPS汇编时按照syscall指令的用法使用*
						  //*测试程序中需出现读语句*

＜写语句＞  ::= printf '(' ＜字符串＞,＜表达式＞ ')'| printf '('＜字符串＞ ')'| printf '('＜表达式＞')' 
						 //*printf '(' ＜字符串＞,＜表达式＞ ')'输出时，先输出字符串的内容，再输出表达式的值，两者之间无空格*
					    //*表达式为字符型时，输出字符；为整型时输出整数*
						//*＜字符串＞原样输出（不存在转义）*
					   //*每个printf语句的内容输出到一行，按结尾有换行符\n处理*
					  //*测试程序中需出现3种形式的写语句*

＜返回语句＞  ::=  return['('＜表达式＞')']  
								//*无返回值的函数中可以没有return语句，也可以有形如return;的语句*
							   //*有返回值的函数只要出现一条带返回值的return语句（表达式带小括号）即可，不用检查每个分支是否有带返回值的return语句*

### 1.2 我对文法的理解

​		整体上来说，文法类似于我们学过的c语言，但比c语言要简单很多，但这也是合乎情理的，毕竟我们暂时还达不到那个能够设计出c语言的编译器。和往年的文法进行对比，我们的文法是在逐渐变得复杂的相。于2019年，我们的文法增加了变量的定义及初始化，同时增加了二维数组，减少了do...while...的循环语句。整体上来看，还是比较合理的，do...while...的与for循环和while循环有很多相似之处，删去可以在不改变知识点的情况下，降低同学们的负担。变量定义及初始化和二维数组则是我们平常在编程中就经常使用的语句，二维数组也比一维数组更有挑战性。据说，下个年度，打算在文法中加入结构体，个人认为这个难度就比较大了，由于结构体比较灵活，存的信息量也比较大，只能祝学弟学妹们好运了。

## 二、词法分析

### 2.1 词法处理要做的工作

​		词法处理就是将输入的文本进行词语的划分，从源程序中识别出单词，记录其单词类别和单词值，以便后续工作的进行。

### 2.2 主要方法及需要注意的点

​		词法分析比较简单，类似于分词，我们要把从源程序中识别出单词，记录其单词类别和单词值，但是与普通的分词不同，普通的分词一般只需要用空格就可以分开，在词法分析中，空格并不能完全分出词，我们还要借助不同单词的特征来识别，如符号和结构等。对于存储单词的结构，需要自己写一个结构体，来记录单词的类别，单词值，行数等信息。对于如何把单词串起来，可以采用数组，也可以采用链表的形式，我个人更喜欢链表的方式，这就不受大小的限制。在使用数组的时候，很多同学就发现数组开小了，导致最后出现了bug。

​		在词法分析中，我们要注意单词的大小问题，我们输出的要求是要输出源程序的单词，但是我们保留字是不区分大小写的，对保留字进行识别的时候就要统一好大小写。另外对于关系运算符，我们要注意两个关系运算符连在一起的时候算一个单词，不可以识别成两个单词。字符串和字符常量的识别也需要多加注意。

## 三、语法分析

### 3.1 语法分析处理要做的工作

​		基于词法分析作业的程序所识别出的单词，识别出各类语法成分。

### 3.2 语法分析的主要方法

​		语法分析程序是我们编译器后续所有工作的主体，可以说词法分析只是基础，语法分析的好坏，很大程度上决定了你之后错误处理和代码生成的代码结构的好坏。从理论上来看，我的语法分析主要采用的是递归子程序法和LL(n)的语法分析。在编译器的概念中，我们最开始的时候我们就接触到了遍的概念，遍通俗的理解就是对源程序的扫描次数，在语法分析中，出现了两种结构，一种是一遍扫描，就是在词法分析的过程中就进行语法分析，一种就是在词法分析后，在得到的词语链上进行。语法分析过程中，我们不可能通过一个单词就确定下一步分析的方向，即一定需要预读下一个单词，或者多个单词，有预读就会有回退。如果我们在词法分析的同时做语法分析，就会出现语法分析等待词法分析，无论是预读还是回退都有很大的难度，但是在词法分析结果后在进行语法分析，预读和回退就会简单的多。词法分析的时候组织单词的时候采用链表，也是为了在语法分析的时候预读和回退方便。

## 四、错误处理

### 4.1 错误处理要做的工作

​		根据给定的文法设计并实现错误处理程序，能诊察出常见的语法和语义错误，进行错误局部化处理，并输出错误信息。

### 4.2 错误处理的具体思路

​		错误处理的主要难点在于符号表的管理和发现错误后语法分析的继续执行。

​		关于符号表，一定要有合理和充分的设计，因为符号表的设计关系到后面的代码生成，设计不当会给代码生成造成很多麻烦。在设计符号表时，为了通过变量名快速查找到符号表中的符号，需要建立一个hash索引表，因为在不同作用域中，可能会出现重名的变量，处理的方法应该是hash表通过重名变量名指向当前作用域的变量，然后在存储当前符号的结构体中设置一个指针指向原来的全局变量。符号表还有一个需要注意的是，函数作为一个作用域，在出了这个作用域后，作用域内的变量都要销毁，销毁的时候hash中也要销毁，hash中销毁的时候，如果该符号的指针还指向了一个全局变量，则需要把该全局变量恢复到hash表中去。

​		关于发现错误后语法分析继续的执行，其实需要做的就是忽略这个错误，或者说发现这个错误，然后进行报错输出，但是我们要假定这个地方有这个语法成分，然后才能继续分析。在我们的错误处理作业中，明确规定了在同一行只能出现一个错误，这个规定会极大降低我们错误处理工作的难度，要合理利用这一点，即如果我们分析了某一行一个错误，就要假定该行不会再有其它错误了。

## 五、代码生成

### 5.1 代码生成要处理的工作

​		代码生成一共可以分为两个部分，一个是生成中间代码，一个是生成目标代码。

### 5.2 代码生成的设计

#### 1、符号表设计与栈设计 

符号表添加一项为存储偏移。char类型也按4字节对齐：

1、对于全局变量和主函数中的变量使用，按照存储偏移量和\$fp位置处取出，\$fp+offset【这里把\$fp设置为0x3000】

2、对于函数内的参数和局部变量，将值存储\$sp寄存器地址下方，即按照 \$sp+offset取局部变量和形参的值

3、函数内部想调用其它函数，则需要把临时寄存器等信息要保留现场，同时把$sp**向下移动函数内形参和临时变量所占空间的总和**【此处应该先把\$sp移动，再保留现场，函数调用结束后，先回复现场，再把\$sp的值加回去，保证能够正确取到这些参数的值】

符号表具体新加内容和要求：
1、全局变量和主函数中的变量的偏移量依次叠加

2、函数的参数和局部变量的偏移量从0开始，且给函数最终一个总偏移量属性

#### 2、四元式修改

|    操作符    |  操作数1   |   操作数2   | 操作数3 |            操作解释             |
| :----------: | :--------: | :---------: | :-----: | :-----------------------------: |
|     ADD      |     rd     |     rs      |   rt    |          rd = rs + rt           |
|     SUB      |     rd     |     rs      |   rt    |          rd = rs - rt           |
|     MULT     |     rd     |     rs      |   rt    |          rd = rs * rt           |
|     DIVI     |     rd     |     rs      |   rt    |          rd = rs / rt           |
| GLOBAL_PARA  |    type    |   offset    |  value  |            常量说明             |
|   FUN_PARA   |    type    |   offset    |  value  |            变量说明             |
|    PRINT     |    type    |  identify   |         |              打印               |
|  STRINGDATA  |   count    | stringconst |         | 以name把stringconst加入data数据 |
| GLOBAL_SCANF |    type    |  identify   |   reg   |              输入               |
|  FUN_SCANF   |    type    |  identify   |   reg   |                                 |
|  GLOBAL_ASS  |    name    |   offset    |   rs    |             rd = rs             |
|   FUN_ASS    |    name    |   offset    |   rs    |                                 |
| STORE_ARRAY  |    name    |   offset    |   rs    |                                 |
|     SET      |    type    |     rd      |   rs    |             rd = rs             |
|    LABEL     |    name    |             |         |       插入标签，名为name        |
|     DATA     |            |             |         |              .data              |
|     TEXT     |            |             |         |              .text              |
|  GET_GPARA   |    name    |   offset    |   reg   |         获取全局变量值          |
|  GET_FPARA   |    name    |   offset    |   reg   |         获取临时变量值          |
|  GET_FPARA2  |    name    |   offset    |   reg   |  获取临时变量值（函数调参用）   |
|     MOVE     |     rs     |     rt      |         |                                 |
|    JLABLE    |            |             |         |           无条件跳转            |
|    CAOF1     |    dim1    |             |   g/f   |        计算一维数组地址         |
|    CAOF2F    | dim2_value |    dim1     |  dim2   |    计算二维数组临时变量地址     |
|    CAOF2G    | dim2_value |    dim1     |  dim2   |    计算二维数组全局变量地址     |
|  LOAD_ARRAY  |    name    |   offset    |   reg   |            读入数组             |
|    BRACH     |     op     |     reg     |  label  |            条件跳转             |
|     JAL      |   label    |             |         |            函数跳转             |
|  RECOVERREG  |     rt     |   offser    |         |         恢复临时寄存器          |
|      JR      |     rt     |             |         |          函数返回语句           |

​		我设计的四元式类型的信息较多，因为要实现将生成目标代码和语法分析等工作分开，需要传给中间代码的信息量很大，而四元式本身能够存储的信息不够多，为了能够充分表达信息，只能加入更多的四元式。四元式种类很多的另一个原因是，我栈结构的设计有关，由于栈的设计严格限定了全局变量和局部变量的存储位置，对于变量的存储和取用都要严格确定其是全局变量还是局部变量，数组的存取又和普通变量的不同，对于函数给形参赋值时也会出现很多不同，所以导致了有大量的寄存器存取的四元式。 

#### 3、表达式分析

设置栈，用来存储因子，将表达式的因子全部存入栈后，扫描栈来生成中间代码。

新创建一个栈内因子的结构体：

{

name；

FactorType:{整数，字符，寄存器，变量，有返回值函数，操作符}；

value;//w为整数或者为字符时使用

OpType:{+,-,*,/,dim1,dim2,fun}

offset：如果是变量，则有偏移量；

is_global;//变量寻址用

pre；

next；

}

```C++
enum FactorType {
	INTCONST,
	CHARCONST, 
	IDENTIFIER,
	RETURNFUN,
	REGISTER,
	OP
};
enum OpType {
	OpAdd,
	OpSub,
	OpMult,
	OpDiv,
	DIM1,
	DIM2,
	NOTOP
};
```

#### 4、条件语句跳转指令：

对于条件判断，都将第一个表达式减去第二个表达式，用得到的值假定为\$t1判断

#### 为了实现条件成立时执行下一条语句不跳转，使用相反的关系运算！

|        指令         | 关系运算 |        描述         |
| :-----------------: | :------: | :-----------------: |
| bne \$t1,\$0, label |    ==    |  相等则跳转至label  |
| beq \$t1,\$0, label |    !=    | 不相等则跳转至label |
|   bgez \$t1,label   |    <     | 大于等于则跳转label |
|   bgtz \$t1,label   |    <=    |   大于则跳转label   |
|   blez \$t1,label   |    >     | 小于等于则跳转label |
|   bltz $t1,label    |    >=    |   小于则跳转label   |

#### 5、跳转的几种结构

##### 1、条件语句：if '('＜条件＞')'＜语句＞［else＜语句＞］

```mips
条件语句（前后表达式计算）
条件不成立时跳转 IF_ELSE_N
条件成立执行语句
[j END_IF_N]
IF_ELSE_N:
[else语句]
END_IF_N:
条件语句外语句
```

##### 2、循环语句之while循环语句 ：while '('＜条件＞')'＜语句＞

```mips
WHILE_N:
条件语句
条件不成立时跳转 END_WHILE_N
条件成立执行语句
j WHILE_N
END_WHILE_N:
其它语句
```

##### 3、循环语句之for循环语句：for'('＜标识符＞＝＜表达式＞;＜条件＞;＜标识符＞＝＜标识符＞(+|-)＜步长＞')'＜语句＞

```mips
＜标识符＞＝＜表达式＞
FOR_N:
条件语句
条件不成立时跳转 END_FOR_N
j FOR_2_N
FOR_1_N:
＜标识符＞＝＜标识符＞(+|-)＜步长＞
j FOR_N
FOR_2_N:
条件成立执行语句
j FOR_1_N
END_FOR_N:
其它语句
//特点，符合输入顺序
```

##### 4、switch语句：switch ‘(’＜表达式＞‘)’ ‘{’＜情况表＞＜缺省＞‘}’  

##### 							＜情况表＞  ::=  ＜情况子语句＞{＜情况子语句＞}

##### 							＜情况子语句＞ ::=  case＜常量＞：＜语句＞ 

##### 							＜缺省＞  ::=  default :＜语句＞        

```mips
<表达式>
SWITCH_N_CASE1:
<表达式> != <常量> branch  SWITCH_N_CASE2:
＜语句＞ 
j END_SWITCH_N
SWITCH_N_CASE2:
<表达式> != <常量> branch  SWITCH_N_CASE3:
＜语句＞ 
j END_SWITCH_N
SWITCH_N_CASE3:
<表达式> != <常量> branch  SWITCH_N_CASE4:
＜语句＞ 
j END_SWITCH_N
SWITCH_N_CASE4:【可能是default语句，但是仍然用case命名】
＜语句＞ 
【是default语句则不需要j End_switch_n】
END_SWITCH_N：
其它语句
```

#### 5、调用函数：

一、调用函数前准备：

1、把 \$sp 下移 offset【主函数内调用则下移global_offset，如果是函数内调用其它函数，则下移fun_offset】

2、保存已使用的临时寄存器的值以及寄存器  \$ra 的值【函数内递归调用才需要保存\$ra】【记录下总偏移， $sp需要向下偏移】

3、将传入参数放在 $sp 下，\$sp不向下偏移

二、调用：jal fun_name

三、调用结束后：

1、恢复临时寄存器中的值和寄存器  \$ra 的值

2、把 \$sp 上移 offset

总结：

​		调用函数是代码生成的一个难点，其中涉及到多方面的内容，说牵一发而动全身毫不夸张，需要注意的点很多，比如如何保存现场，如何恢复现场，堆栈的结构变化，函数的递归调用，调用函数传入的形参也是函数等问题都很棘手，需要反复思考栈的结构，合理修改全局变量的状态。

#### 6、生成mips代码；

​		生成mips代码没有太多的技巧，根据中间代码四元式提供的信息，一步步将中间代码翻译成mips代码即可

## 六、中间优化

### 6.1 寄存器的分配使用

​		我使用的寄存器主要有 \$sp, \$fp, \$s0, \$s1, \$a0, \$t0-\$t1，其中\$t0-\$t1是临时寄存器，临时寄存器的使用策略是先来先用，预先设置了一个寄存器池，当需要使用寄存器时，从寄存器池中返回一个寄存器，在寄存器使用过后立马释放该寄存器。一个优化的点是，当寄存器需要二元运算的时候，将运算的寄存器运算的结果放在第一个参与运算的寄存器内，这样就可以不用重新分配寄存器了。

### 6.2 保存现场

​		保存现场时，需要对使用的临时寄存器进行存储，分配的时候需要移动 \$sp寄存器，移动的时候不能一次一次移，而是记录下总的移动大小，一次性移动，减少mips指令。

### 6.3 基本块的划分

​		基本块的划分可以根据 label 和跳转指令来划分，这两种指令之间的代码块属于一个基本块，这样划分简单快捷。

### 6.4 对同一变量存储后立即取用

​		对变量进行存储后，如果需要立即使用，由于是存储的时候已经将变量的值放在一个寄存器内，可以在延迟释放该寄存器，后续使用该变量的时候，直接使用该寄存器即可。

### 6.5 字符串输出

​		代码中有很多地方输出字符串，输出字符串的处理方法是将字符串存放在.data下，调用的时候直接把字符串的名称【相当于字符串的存储地址】给寄存器，然后调用syscall。

### 6.6 总结

​		由于时间原因，没有太多时间去做代码优化，但个人认为很多可以在中间代码层优化的地方，在生成中间代码的时候就可以考虑到，直接在生成中间代码的时候可以降低优化的工作量。本人在没有做什么情况下就可以在排名中到达一个中间水平，更多就是归功于生成代码时想得更多，设计得更简便。另外一个问题就是一定要避免负优化。